<!-- Hencurve Anchors -->
<script>
  (function (document, window) {
    let HencurveAnchors = {
      containers: undefined,
      isMobile: false,

      _init: function () {
        if (this.isMobile) return;

        this.containers = document.querySelectorAll(
          ".hencurve-anchors-container",
        );
        if (!this.containers.length) return;

        this.containers.forEach((container) => {
          this._drawSVG(container);
        });
      },

      _drawSVG: function (container) {
        let svgInstance = SVG()
          .addTo(container)
          .size("100%", "100%")
          .addClass("hencurve-anchors-svg");

        this._findAnchors(container, svgInstance);
      },

      _findAnchors: function (container, svgInstance) {
        const anchors = container.querySelectorAll(".hencurve-anchor");

        if (anchors.length < 2) return;

        const firstAnchor = anchors[0].getBoundingClientRect();
        const secondAnchor = anchors[1].getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();

        const firstAnchorPos = {
          x: firstAnchor.left - containerRect.left,
          y: firstAnchor.top - containerRect.top + firstAnchor.height,
          width: firstAnchor.width,
        };

        const secondAnchorPos = {
          x: secondAnchor.left - containerRect.left,
          y: secondAnchor.top - containerRect.top,
          width: secondAnchor.width,
        };

        const curveColor = window.getComputedStyle(anchors[0]).color;

        this._drawPath(
          container,
          svgInstance,
          firstAnchorPos,
          secondAnchorPos,
          curveColor,
        );
      },

      _drawPath: function (
        container,
        svgInstance,
        firstAnchor,
        secondAnchor,
        curveColor,
      ) {
        const siteMargin = 36;
        const svgHeight = container.offsetHeight;
        const strokeWidth = 6;

        const startX = siteMargin;
        const endX = window.innerWidth - siteMargin;

        const startY =
          firstAnchor.y > secondAnchor.y
            ? svgHeight - strokeWidth
            : strokeWidth;
        const endY = firstAnchor.y > secondAnchor.y ? 0 : svgHeight;

        const firstAnchorEndX = firstAnchor.x + firstAnchor.width;
        const firstAnchorEndY = firstAnchor.y;

        const secondAnchorStartX = secondAnchor.x;
        let secondAnchorStartY =
          firstAnchor.y > secondAnchor.y
            ? endY + strokeWidth
            : endY - strokeWidth;

        const totalSpace = secondAnchorStartX - firstAnchorEndX;
        const arcSpace = totalSpace / 2;

        if (arcSpace < 0) {
          console.warn(
            "Not enough space for arcs. Adjust layout or stroke width.",
          );
          return;
        }

        const arcRadius = Math.abs(firstAnchorEndY - secondAnchorStartY) / 2;

        let pathData = `M ${startX}, ${startY} \n`;
        const arc1StartX = firstAnchorEndX + arcSpace - arcRadius;
        pathData += `H ${arc1StartX} \n`;

        const arc1Direction = firstAnchorEndY < secondAnchorStartY ? 1 : 0;
        pathData += `a ${arcRadius},${arcRadius} 90 0 ${arc1Direction} ${arcRadius},${arc1Direction ? arcRadius : -arcRadius} \n`;

        const arc2Direction = arc1Direction ? 0 : 1;
        pathData += `a ${arcRadius},${arcRadius} 90 0 ${arc2Direction} ${arcRadius},${arc2Direction ? -arcRadius : arcRadius} \n`;

        pathData += `H ${endX} \n`;

        svgInstance
          .path(pathData)
          .stroke({
            color: curveColor,
            width: strokeWidth,
          })
          .fill("none");

        this.onCompleteEvent(container);
      },

      animateSVG(container) {
        const reversePathDraw = false;
        gsap.registerPlugin(ScrollTrigger, DrawSVGPlugin);

        if (
          document.body.classList.contains("error404") ||
          container.classList.contains("is-about-us-hero")
        ) {
          gsap.fromTo(
            ".hencurve-anchors-svg path",
            { drawSVG: "0%" },
            { drawSVG: "100%" },
          );
        } else {
          gsap.fromTo(
            ".hencurve-anchors-svg path",
            { drawSVG: reversePathDraw ? "100% 100%" : "0% 0%" },
            {
              drawSVG: "0% 100%",
              scrollTrigger: {
                trigger: container,
                start: `top center`,
                end: `+=300`,
                scrub: 1,
              },
            },
          );
        }
      },

      onCompleteEvent(container) {
        const event = new CustomEvent("hencurvesPathReady", {
          detail: {
            block: container,
            blockId: container.id,
          },
        });

        this.animateSVG(container);
        document.dispatchEvent(event);
      },

      _destroy: function () {
        document
          .querySelectorAll(".hencurve-anchors-container svg")
          .forEach((svg) => svg.remove());
      },
    };

    const handleResize = debounce(() => {
      if (!HencurveAnchors.isMobile) {
        HencurveAnchors._destroy();
        HencurveAnchors._init();
      }
    }, 200);

    const mm = gsap.matchMedia();
    const breakPoint = 1024;

    mm.add(`(max-width: ${breakPoint}px)`, () => {
      HencurveAnchors.isMobile = true;
      HencurveAnchors._destroy();
    });

    mm.add(`(min-width: ${breakPoint + 1}px)`, () => {
      HencurveAnchors.isMobile = false;
      HencurveAnchors._init();
    });

    document.addEventListener("DOMContentLoaded", () => {
      window.addEventListener("resize", handleResize);
    });

    window.addEventListener("load", handleResize);
  })(document, window);
</script>
